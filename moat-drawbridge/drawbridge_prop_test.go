package main

import (
	"crypto/ed25519"
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"math/rand"
	"os"
	"strconv"
	"testing"
	"time"
)

// ── Cross-language test vectors ─────────────────────────────────

type ChallengeVector struct {
	Nonce        string `json:"nonce"`
	URL          string `json:"url"`
	Timestamp    int64  `json:"timestamp"`
	MessageHex   string `json:"message_hex"`
	PublicKeyB64 string `json:"public_key_b64"`
	SignatureB64 string `json:"signature_b64"`
}

// TestCrossLanguage_ChallengeVectors verifies that Ed25519 signatures
// generated by Rust's ed25519_dalek verify under Go's crypto/ed25519.
// This proves both sides construct the same signed message bytes.
func TestCrossLanguage_ChallengeVectors(t *testing.T) {
	data, err := os.ReadFile("testdata/challenge_vectors.json")
	if err != nil {
		t.Fatalf("failed to read test vectors: %v", err)
	}

	var vectors []ChallengeVector
	if err := json.Unmarshal(data, &vectors); err != nil {
		t.Fatalf("failed to parse test vectors: %v", err)
	}

	for i, v := range vectors {
		// Decode Rust-generated signature and public key
		pubKeyBytes, err := base64.StdEncoding.DecodeString(v.PublicKeyB64)
		if err != nil {
			t.Fatalf("vector %d: failed to decode public key: %v", i, err)
		}
		sigBytes, err := base64.StdEncoding.DecodeString(v.SignatureB64)
		if err != nil {
			t.Fatalf("vector %d: failed to decode signature: %v", i, err)
		}

		// Verify the Rust-generated signature using Go's crypto/ed25519
		if !ed25519.Verify(pubKeyBytes, mustDecodeHex(t, v.MessageHex), sigBytes) {
			t.Fatalf("vector %d: Rust-generated signature FAILED Go verification (nonce=%q url=%q ts=%d)",
				i, v.Nonce, v.URL, v.Timestamp)
		}

		// Also verify that Go constructs the same message bytes
		goMessage := verifyChallenge_buildMessage(v.Nonce, v.URL, v.Timestamp)
		goMessageHex := hex.EncodeToString(goMessage)
		if goMessageHex != v.MessageHex {
			t.Fatalf("vector %d: message format mismatch:\n  Go:   %s\n  Rust: %s",
				i, goMessageHex, v.MessageHex)
		}

		// And verify the signature against Go's constructed message
		if err := verifyChallenge(pubKeyBytes, v.Nonce, v.URL, v.Timestamp, sigBytes); err != nil {
			t.Fatalf("vector %d: verifyChallenge failed: %v", i, err)
		}
	}

	t.Logf("verified %d cross-language challenge vectors", len(vectors))
}

func mustDecodeHex(t *testing.T, s string) []byte {
	t.Helper()
	b, err := hex.DecodeString(s)
	if err != nil {
		t.Fatalf("failed to decode hex: %v", err)
	}
	return b
}

// verifyChallenge_buildMessage extracts message construction for testing.
func verifyChallenge_buildMessage(nonce, relayURL string, timestamp int64) []byte {
	return []byte(nonce + "\n" + relayURL + "\n" + strconv.FormatInt(timestamp, 10) + "\n")
}

// ── update_tags with overlapping add/remove ─────────────────────

// Property: When a tag appears in both Add and Remove, add wins (runs second).
func TestProp_UpdateTagsOverlap(t *testing.T) {
	rng := rand.New(rand.NewSource(50))

	for i := 0; i < 100; i++ {
		env := newPropEnv()
		c := &Client{
			relay:    env.relay,
			did:      randomDID(rng),
			authMode: AuthModeSender,
			tags:     make(map[string]bool),
			send:     make(chan []byte, 10),
		}
		env.relay.register(c)

		// Start with some tags
		initialTags := make([]string, rng.Intn(5)+1)
		for j := range initialTags {
			initialTags[j] = randomTag(rng)
		}
		env.relay.handleWatchTags(c, &WatchTagsMsg{Tags: initialTags})

		// Generate overlapping add/remove sets
		overlapTag := randomTag(rng) // this tag will be in BOTH add and remove
		toRemove := []string{overlapTag}
		toAdd := []string{overlapTag}

		// Add some non-overlapping ones too
		for j := 0; j < rng.Intn(3); j++ {
			toRemove = append(toRemove, initialTags[rng.Intn(len(initialTags))])
		}
		for j := 0; j < rng.Intn(3); j++ {
			toAdd = append(toAdd, randomTag(rng))
		}

		env.relay.handleUpdateTags(c, &UpdateTagsMsg{Add: toAdd, Remove: toRemove})

		// The overlap tag should be present (add runs after remove)
		env.relay.mu.RLock()
		if !c.tags[overlapTag] {
			t.Fatalf("iteration %d: overlapping tag should be present after update_tags (add wins over remove)", i)
		}
		// Also check byTag consistency
		if _, ok := env.relay.byTag[overlapTag]; !ok || !env.relay.byTag[overlapTag][c] {
			t.Fatalf("iteration %d: overlapping tag missing from byTag index", i)
		}
		env.relay.mu.RUnlock()
	}
}

// ── Ticket hex validation gap ───────────────────────────────────

// Property: 64-char non-hex strings pass length check but the ticket
// won't exist, so authenticateTicket returns "invalid ticket" (not format error).
func TestProp_TicketNonHexPassesLengthCheck(t *testing.T) {
	rng := rand.New(rand.NewSource(51))
	charset := "ghijklmnopqrstuvwxyz!@#$%^&*()" // non-hex chars

	for i := 0; i < 50; i++ {
		env := newPropEnv()

		// Generate a 64-char string with non-hex characters
		ticket := make([]byte, 64)
		for j := range ticket {
			ticket[j] = charset[rng.Intn(len(charset))]
		}
		ticketStr := string(ticket)

		c := &Client{send: make(chan []byte, 10)}
		err := env.relay.authenticateTicket(c, ticketStr)

		// Should fail with "invalid ticket" (not found), not "invalid format"
		if err == nil {
			t.Fatalf("iteration %d: non-hex ticket was accepted", i)
		}
		if err.Error() == "invalid ticket format" {
			t.Fatalf("iteration %d: 64-char non-hex ticket rejected as format error, should be 'invalid ticket'", i)
		}
	}
}

// Property: Tickets shorter or longer than 64 chars always get format error.
func TestProp_TicketLengthValidation(t *testing.T) {
	rng := rand.New(rand.NewSource(52))

	for i := 0; i < 100; i++ {
		env := newPropEnv()

		// Random length != 64
		length := rng.Intn(128)
		if length == 64 {
			length = 65
		}

		ticket := make([]byte, length)
		for j := range ticket {
			ticket[j] = "0123456789abcdef"[rng.Intn(16)]
		}
		ticketStr := string(ticket)

		c := &Client{send: make(chan []byte, 10)}
		err := env.relay.authenticateTicket(c, ticketStr)

		if err == nil {
			t.Fatalf("iteration %d: ticket of length %d was accepted", i, length)
		}
		if err.Error() != "invalid ticket format" {
			t.Fatalf("iteration %d: ticket length %d got error %q, expected 'invalid ticket format'", i, length, err.Error())
		}
	}
}

// ── Dedup cleanup removes stale entries ─────────────────────────

// Property: After cleanup, no entry in dedup is older than 5 seconds.
func TestProp_DedupCleanupRemovesStale(t *testing.T) {
	rng := rand.New(rand.NewSource(53))

	for i := 0; i < 50; i++ {
		env := newPropEnv()

		// Insert entries with various ages
		now := time.Now()
		numEntries := rng.Intn(20) + 1
		var expectedSurvivors int

		env.relay.dedupMu.Lock()
		for j := 0; j < numEntries; j++ {
			key := randomTag(rng) + ":" + randomTag(rng)
			ageSecs := rng.Intn(15) // 0-14 seconds old
			entryTime := now.Add(-time.Duration(ageSecs) * time.Second)
			env.relay.dedup[key] = entryTime

			if ageSecs <= 5 {
				expectedSurvivors++
			}
		}
		env.relay.dedupMu.Unlock()

		// Run cleanup
		env.relay.cleanupDedup()

		// Verify: no entry is older than 5 seconds
		env.relay.dedupMu.Lock()
		for key, entryTime := range env.relay.dedup {
			age := time.Since(entryTime)
			if age > 6*time.Second { // small buffer for test execution time
				t.Fatalf("iteration %d: dedup entry %q is %v old after cleanup", i, key, age)
			}
		}
		remaining := len(env.relay.dedup)
		env.relay.dedupMu.Unlock()

		if remaining > expectedSurvivors {
			t.Fatalf("iteration %d: expected at most %d survivors, got %d", i, expectedSurvivors, remaining)
		}
	}
}

// ── Ticket registration conflict ────────────────────────────────

// Property: A ticket registered by DID A cannot be stolen by DID B.
func TestProp_TicketRegistrationConflict(t *testing.T) {
	rng := rand.New(rand.NewSource(54))

	for i := 0; i < 100; i++ {
		env := newPropEnv()
		ticket := randomTicket(rng)
		ownerDID := randomDID(rng)
		attackerDID := randomDID(rng)

		// Owner registers
		ownerClient := &Client{did: ownerDID, authMode: AuthModeSender, send: make(chan []byte, 10)}
		env.relay.handleRegisterTicket(ownerClient, &RegisterTicketMsg{Ticket: ticket})

		// Attacker tries to register same ticket
		attackerClient := &Client{did: attackerDID, authMode: AuthModeSender, send: make(chan []byte, 10)}
		env.relay.handleRegisterTicket(attackerClient, &RegisterTicketMsg{Ticket: ticket})

		// Ticket should still belong to owner
		env.relay.ticketsMu.RLock()
		owner := env.relay.tickets[ticket]
		env.relay.ticketsMu.RUnlock()

		if owner != ownerDID {
			t.Fatalf("iteration %d: ticket owner changed from %s to %s", i, ownerDID, owner)
		}

		// Attacker should have received an error message
		select {
		case msg := <-attackerClient.send:
			var resp map[string]interface{}
			json.Unmarshal(msg, &resp)
			if resp["type"] != "error" {
				t.Fatalf("iteration %d: attacker got %v instead of error", i, resp["type"])
			}
		default:
			t.Fatalf("iteration %d: attacker did not receive error response", i)
		}
	}
}
