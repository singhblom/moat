// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `from_core`, `into_core`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `MoatError`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `from`, `from`, `from`, `from`

/// Generate a stealth keypair. Returns (private_key, public_key) each 32 bytes.
StealthKeypair generateStealthKeypair() =>
    RustLib.instance.api.crateApiSimpleGenerateStealthKeypair();

/// Encrypt a Welcome for one or more recipients' stealth addresses (multi-device support).
/// Each recipient pubkey must be 32 bytes.
Future<Uint8List> encryptForStealth({
  required List<Uint8List> recipientScanPubkeys,
  required List<int> welcomeBytes,
}) => RustLib.instance.api.crateApiSimpleEncryptForStealth(
  recipientScanPubkeys: recipientScanPubkeys,
  welcomeBytes: welcomeBytes,
);

/// Try to decrypt a stealth-encrypted payload. Returns None if not for us.
Uint8List? tryDecryptStealth({
  required List<int> scanPrivkey,
  required List<int> payload,
}) => RustLib.instance.api.crateApiSimpleTryDecryptStealth(
  scanPrivkey: scanPrivkey,
  payload: payload,
);

/// Generate candidate tags for recipient scanning.
///
/// Returns a list of (tag, counter) pairs for the given sender in the group.
List<Uint8List> generateCandidateTags({
  required MoatSessionHandle handle,
  required List<int> groupId,
  required String senderDid,
  required List<int> senderDeviceId,
  required BigInt fromCounter,
  required BigInt count,
}) => RustLib.instance.api.crateApiSimpleGenerateCandidateTags(
  handle: handle,
  groupId: groupId,
  senderDid: senderDid,
  senderDeviceId: senderDeviceId,
  fromCounter: fromCounter,
  count: count,
);

/// Derive the next unique tag for publishing an event (increments counter).
Uint8List deriveNextTag({
  required MoatSessionHandle handle,
  required List<int> groupId,
  required List<int> keyBundle,
}) => RustLib.instance.api.crateApiSimpleDeriveNextTag(
  handle: handle,
  groupId: groupId,
  keyBundle: keyBundle,
);

/// Pad plaintext to bucket size (256, 1024, or 4096 bytes).
Uint8List padToBucket({required List<int> plaintext}) =>
    RustLib.instance.api.crateApiSimplePadToBucket(plaintext: plaintext);

/// Remove padding and extract original plaintext.
Uint8List unpad({required List<int> padded}) =>
    RustLib.instance.api.crateApiSimpleUnpad(padded: padded);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MoatSessionHandle>>
abstract class MoatSessionHandle implements RustOpaqueInterface {
  /// Add a member to a group. Returns welcome result.
  Future<WelcomeResultDto> addMember({
    required List<int> groupId,
    required List<int> keyBundle,
    required List<int> newMemberKeyPackage,
  });

  /// Create a new MLS group with DID and device name. Returns the group ID.
  Future<Uint8List> createGroup({
    required String did,
    required String deviceName,
    required List<int> keyBundle,
  });

  /// Decrypt a ciphertext for a group. Returns decrypt result with any warnings.
  Future<DecryptResultDto> decryptEvent({
    required List<int> groupId,
    required List<int> ciphertext,
  });

  /// Get the 16-byte device ID.
  Uint8List deviceId();

  /// Encrypt an event for a group. Returns encrypt result.
  Future<EncryptResultDto> encryptEvent({
    required List<int> groupId,
    required List<int> keyBundle,
    required EventDto event,
  });

  /// Export the full session state as bytes for persistence.
  Future<Uint8List> exportState();

  /// Restore a session from previously exported state bytes.
  static Future<MoatSessionHandle> fromState({required List<int> state}) =>
      RustLib.instance.api.crateApiSimpleMoatSessionHandleFromState(
        state: state,
      );

  /// Generate a new key package with DID and device name.
  /// Returns (key_package_bytes, key_bundle_bytes).
  Future<KeyPackageResult> generateKeyPackage({
    required String did,
    required String deviceName,
  });

  /// Get the DIDs of all members in a group (deduplicated).
  Future<List<String>> getGroupDids({required List<int> groupId});

  /// Get the current epoch of a group. Returns null if group doesn't exist.
  Future<BigInt?> getGroupEpoch({required List<int> groupId});

  /// Check if there are unsaved changes.
  bool hasPendingChanges();

  /// Mark a tag as seen, advancing the seen counter for that sender.
  ///
  /// Call this after matching a tag from `populate_candidate_tags`.
  /// Returns true if the tag was found and the counter was updated.
  bool markTagSeen({required List<int> tag});

  /// Create a new session with empty state.
  static MoatSessionHandle newSession() =>
      RustLib.instance.api.crateApiSimpleMoatSessionHandleNewSession();

  /// Generate all candidate tags for every member in a group.
  ///
  /// Returns a flat list of candidate tags for recipient scanning.
  List<Uint8List> populateCandidateTags({required List<int> groupId});

  /// Process a welcome message to join a group. Returns the group ID.
  Future<Uint8List> processWelcome({required List<int> welcomeBytes});
}

class DecryptResultDto {
  final Uint8List newGroupState;
  final EventDto event;
  final SenderInfoDto? sender;

  /// Transcript integrity warnings (empty if none).
  final List<String> warnings;

  const DecryptResultDto({
    required this.newGroupState,
    required this.event,
    this.sender,
    required this.warnings,
  });

  @override
  int get hashCode =>
      newGroupState.hashCode ^
      event.hashCode ^
      sender.hashCode ^
      warnings.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DecryptResultDto &&
          runtimeType == other.runtimeType &&
          newGroupState == other.newGroupState &&
          event == other.event &&
          sender == other.sender &&
          warnings == other.warnings;
}

class EncryptResultDto {
  final Uint8List newGroupState;
  final Uint8List tag;
  final Uint8List ciphertext;

  /// The message_id assigned to the event (16 bytes for Message/Reaction, None otherwise)
  final Uint8List? messageId;

  const EncryptResultDto({
    required this.newGroupState,
    required this.tag,
    required this.ciphertext,
    this.messageId,
  });

  @override
  int get hashCode =>
      newGroupState.hashCode ^
      tag.hashCode ^
      ciphertext.hashCode ^
      messageId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EncryptResultDto &&
          runtimeType == other.runtimeType &&
          newGroupState == other.newGroupState &&
          tag == other.tag &&
          ciphertext == other.ciphertext &&
          messageId == other.messageId;
}

class EventDto {
  final EventKindDto kind;
  final Uint8List groupId;
  final BigInt epoch;
  final Uint8List payload;

  /// Unique message identifier (16 random bytes). Present for Message and Reaction events.
  final Uint8List? messageId;

  const EventDto({
    required this.kind,
    required this.groupId,
    required this.epoch,
    required this.payload,
    this.messageId,
  });

  /// Parse the payload as a reaction. Only valid when kind is Reaction.
  /// Returns None if this is not a Reaction event or if the payload is malformed.
  ReactionPayloadDto? reactionPayload() =>
      RustLib.instance.api.crateApiSimpleEventDtoReactionPayload(that: this);

  @override
  int get hashCode =>
      kind.hashCode ^
      groupId.hashCode ^
      epoch.hashCode ^
      payload.hashCode ^
      messageId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EventDto &&
          runtimeType == other.runtimeType &&
          kind == other.kind &&
          groupId == other.groupId &&
          epoch == other.epoch &&
          payload == other.payload &&
          messageId == other.messageId;
}

enum EventKindDto { message, commit, welcome, checkpoint, reaction }

class KeyPackageResult {
  final Uint8List keyPackage;
  final Uint8List keyBundle;

  const KeyPackageResult({required this.keyPackage, required this.keyBundle});

  @override
  int get hashCode => keyPackage.hashCode ^ keyBundle.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is KeyPackageResult &&
          runtimeType == other.runtimeType &&
          keyPackage == other.keyPackage &&
          keyBundle == other.keyBundle;
}

/// Reaction payload extracted from a Reaction event.
class ReactionPayloadDto {
  final String emoji;
  final Uint8List targetMessageId;

  const ReactionPayloadDto({
    required this.emoji,
    required this.targetMessageId,
  });

  @override
  int get hashCode => emoji.hashCode ^ targetMessageId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ReactionPayloadDto &&
          runtimeType == other.runtimeType &&
          emoji == other.emoji &&
          targetMessageId == other.targetMessageId;
}

/// Information about the sender of a message, extracted from MLS credentials.
class SenderInfoDto {
  /// The sender's DID (e.g., "did:plc:abc123")
  final String did;

  /// The sender's device name (format: "did:plc:xxx/Device Name")
  final String deviceName;

  const SenderInfoDto({required this.did, required this.deviceName});

  @override
  int get hashCode => did.hashCode ^ deviceName.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SenderInfoDto &&
          runtimeType == other.runtimeType &&
          did == other.did &&
          deviceName == other.deviceName;
}

class StealthKeypair {
  final Uint8List privateKey;
  final Uint8List publicKey;

  const StealthKeypair({required this.privateKey, required this.publicKey});

  @override
  int get hashCode => privateKey.hashCode ^ publicKey.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is StealthKeypair &&
          runtimeType == other.runtimeType &&
          privateKey == other.privateKey &&
          publicKey == other.publicKey;
}

class WelcomeResultDto {
  final Uint8List newGroupState;
  final Uint8List welcome;
  final Uint8List commit;
  final Uint8List groupId;

  const WelcomeResultDto({
    required this.newGroupState,
    required this.welcome,
    required this.commit,
    required this.groupId,
  });

  @override
  int get hashCode =>
      newGroupState.hashCode ^
      welcome.hashCode ^
      commit.hashCode ^
      groupId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WelcomeResultDto &&
          runtimeType == other.runtimeType &&
          newGroupState == other.newGroupState &&
          welcome == other.welcome &&
          commit == other.commit &&
          groupId == other.groupId;
}
